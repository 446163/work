#  **Unit 14 - Event driven programming**

> Assignment 1 - How to start

_Daniel Easteal_

<div style="page-break-after: always;"></div>

## Contents page 

Introduction - 

P1 - Explain the key features of event driven programs

P2 - demonstrate the use of event driven tools and techniques

M1 - Discuss how an operating system can be viewed as an event driven application

D1 - evaluate the suitability of event driven programs for non-graphical applications

Conclusion - 

Bibliography - 

<div style="page-break-after: always;"></div>

## Introduction

In this assignment I will be going through and explaining how event driven programming works as well as how it can be used in practice and how it can then be implemented. 

## P1 - Explain the key features of event driven programs
 
For this section I will explain what event driven programming is as well as a few of the features that it has and finally some examples of how they work. 

### Definition

The main feature that defines the use of event driven programming is the idea that the all the functionality of the program will come from the interaction that the user has with the software and nothing will really be happening when the uses does not tell it to. This will mean that the software will react to the users input rather then processing information that it has like most other programming languages. You may say that almost all programming is like this due to the fact that it will have to react to the input that the user gives it as otherwise the software will be hardcoded and will only be able to produce the same output over and over again. But, this type of programming is used when you want to interface with something and you need to see when the user would have clicked a button or when they added something to a list rather than seeing what they provided as an argument to a program.

From Wikipedia, the definition of event driven programming is as follows:

> In computer programming, event-driven programming is a programming paradigm
> in which the flow of the program is determined by events such as user actions
> (mouse clicks, key presses), sensor outputs, or messages from other programs/threads. 

As you can see, this covers the same points that I have said but with covers a bit more information. This will there for mean that the programming for this will end up being a lot of user interface as well as GUI applications. 

### Event driven programming language

When you are programming with event driven programming you will need to select the programming language that you wait to use. The main programming languages that are suitable for this section would be:

* Visual Basic
* Visual C++
* Java

For all of these, they work in a very similar fashion but there are a few small differences about how they are used. For example, Visual basic is used mainly for small applications on windows operating systems, or in the creation of forms for Microsoft Office programs like access or excel. Visual C++ is generally used for small but powerful programs that need to either be specifically fast or work on a embedded device. Java is used in all other sections and is the main general case language. 

### Event driven systems

When you are programming and using event driven systems, there are certain factors that will be different to if you were program with another type of programming. The main features that are part of event driven programming would be the fact that they are easy to program simple functionality in this there for makes it easy to develop in, in addition to this event driven programming is also often service and time oriented. When I say that programming is easy and quick with these programming languages I mean that when you program with these languages you can see the results of the program very quickly and then see how the program is going very well. This will increase the ease of development of the program as the progress can be very easily seen and so the small goals that are throughout the project can be achieved very quickly. This is also helped by the fact that the programming language is very simple to program with due to the commands and other features being in general user friendly they are very quick to use. In addition to this programming in this way will often be done in a service oriented and time driven manner. This is done like this due to the fact that most of the programs that will be created by an event driven programming languages will be used in GUI applications that will be more aimed to the general market and so the project will need to be providing a service to the customers and as such the whole project will need to be oriented for this service. Furthermore, due to the fact that programming in this way is very quick and simple there way that 

### Features

Due to the fact that event driven programming it used for GUI and human interaction the features that it has at the heart of the process are well defined and fit for purpose. For example their are many ways that event driven programming languages will be able to detect and know that a human interaction has gone on. What I mean by this is that there are many different inputs that the user of the program can put in can be detected. This ranges from the simple like a mouse click of cursor location all the way up to the complex of unique sensors that can detect pressure and so on. In order for the detection of sensors and so on to work there needs to a small running process in the background that actually detects when the value of the sensors has changed so that the program can carry on to work and actually process the information that it needs to do. This small process that runs in the background is called the event loop because it is the loop that runs over and over again to detect the events that the program will run off of. 

### Examples

There are many different examples of how and where event driven programming can be used but for this I will only cover a few. The main example that comes to mind is the programming that is a part of forms that you would fill out in order to search in a database. This would use event driven programming due to the fact that the program will not search through the database until the user has clicked the button to that tell the program that the information that needs to be searched for has all been input. The program will use the features of event driven programming like mouse clicks and so on to know when the user has done with the data input. This is why most of the Microsoft office suite comer with the ability to make forms and macros' and so on with the programming language of visual basic as it is an event driven programming language. Another place that event driven programming is used is in GUI applications in general,  this is because with all GUI applications they well need to wait for either the user or anther process to access them so that they can display the information that they need to on the screen. Although event driven programming languages well often have ways that they can run the background process, they are not really designed for this and so they will not be as efficient or as fast as the process could be done. 

## P2 - demonstrate the use of event driven tools and techniques

In this section I will be going through some examples of how event driven programming is used and how the techniques that I mentioned before are actually used in practice and how they could be programmed. For this I will be exalting the use of the following features:

* tool boxes and controls
* selection
* loops
* event handlers
* triggers, objects and object properties
* menus
* debugging tools 

### Tool boxes and controls

When using visual basic there will be a toolbox off to the side that you can use to select different controls from that are all used as a form of control within the program that you are making and all of there are the human inputs that I mentioned in the previous section. From this control box all of the following items that I will talk about can be accessed and added into the program. You can gain access to the tools by clicking on the toolbox tab and then clicking and then you will see the following menu appear:

![Control tools](http://www.homeandlearn.co.uk/NET/images/vb_2015/toolbox/toolbox.gif)

From here you can then click on the common contrlos sub-menu and you will see a list of the most commonly used tools that I will partly go through in this section:

![Control tools](http://www.homeandlearn.co.uk/NET/images/vb_2013/getting_started/common_controls.gif)

### Selection

When you want to select something in the form that you are creating the process is very simple as you just have to click on the item that you want to select and then it will be selected for you. From here you can then choose to delete the item or change it in any way that you want to. However, the term selection may also mean the process of selecting information that you want to process or a certain part of the program to run depending on the state of the program. The main way that this is is done in most programming languages is through the use of 'if' statements. With if statements the program can bract off and perform different tasks depending on the value of a poise of memory. An example of a typical 'if' statement would look like the following:

``` 
int a = 1
if ( a == 1 ) {
	/* run this code if a is equal to 1 */
}else{
	/* run this code if a is not equal to 1 */
}
```

As you can see, in this very small program there well be different paces of code executed depending on the value of a. To start off with, in the program the variable 'a' is created and it it told that it is a number that has a value of 1. On the next line the value of a is tested to see if it is the equal to the value of 1. If the value of a is equal to 1 then the program will run the code where it states this on the next line. Then there is the else statement, this means the opposite of the if and this will run if the value of a is not 1. The next line is then the code that will run if the value of a is not 1. Finally the if statement is closed off. From this you can see that a program can very easily make a selecting from information that it has and this can lead to the program taking or rather selecting what it needs to run. 

### Loops

Another main section that all programming languages use is loops, as you could guess from the name, loops are used to run a section of code over and over again and they have the ability to change the state of a variable depending on how many times the loop has run. Due to the fact that loops are needed there are 2 main types of loops that are used in most programming languages and these are 'for' and 'while' loops. The way that they both work is very similar but generally the for loop is used when you need to recur a process a set number of times while a while loop is used when you want to recur something an unknown number of times when you are creating the loop. Below there will be an example of each so that you can see how they are laid out, first there is a while loop:

```
sensor a = /dev/pressure1
while ( a > 10 ) {
	/* run this code */
	a = /dev/pressure1
}
```

From this you can see that at the start the value of the variable a is set to the value of the pressure sensor that the computer is plugged into. Then the loop starts and as you can see, the program will run the loop over and over again while the value of a is grades than 10, as soon as the value of 'a' changes and it is not greater that 10 then the loop will stop and the program will skip past it. One thing to note is that for a while loop you need to have the value that you are testing, be changed in the while loop. This is needed because without this the loop would never end and the code could run in the loop forever and the program would not work. Due to this the code in the loop will re-read the value of the sensor and so there will be an opportunity where the loop will stop and so this is a valid while loop. As you can see, for this loop you would not know how many different times you would need to run the loop and so the while low would be the one that you would use. 

In addition to the while loop there is also the 'for' loop and this is used when you know how many times you need to run the loop, so here is an example:

```
for ( i = 0; i < 100; i++) {
	*/ this code will run 100 times */
}
```

In this example the loop will run the code inside it 100 times and then stop. The formatting for this loop is a bit strange but it is easy to explain and so I will go through that now. The first part of the loop is the 'for (', this is just used to start the loop and tell the compiler that there will be a loop here. The next part of 'i = 0;' tells the compiler that there will be a new variable called 'i' that will hold the value of the loop and will change value each time the loop repeats. The next part of 'i < 100;' tells the compiler that the loop will keep on going while the value of i is less that 100 in this case. It is similar to a while loop in this respect but it is just all in one. The final part of the loop is 'i++ )', this tells the loop how to change the value of i with each pass of the loop so that it can count the value correctly. In this case the value of i will increase by 1 each pass of the loop as 'i++' is the same as 'i = i + 1' in most programming languages. Finally the ')' closes the logic part of the loop and the '{' opens the code of the loop. As you can see, in this example the value of i starts at 1 and increases by 1 until it gets to 100, so the loop will run 100 times. 

As you can see loops help you control a program by ensuring that you don't have to write out parts of the program over and over again. In addition to this you can also use the value of the loop variable in the loop so that you can run the parts of the loop over with a different value each time.

### Event Handlers

When you are programming in an event driven programming language event handlers will be needed in most cases. An event handler is a small section of code or 'routine' that is used to handle and process actions that the user would input to the program that need to be caught in a separate line of processing to the main code. This will cover things like mouse movements and keystrokes (key presses). The reason that these cannot be run in the main thread is that the process will have to wait for the user to potentially press a key and if the program is waiting for this then it cannot carry on with the rest of the stuff that it has to do and so the program would not work. For example say that your program would have the option to press 'w' and move forward when you do so. Then you might think that you could code like so:

```
...
if ( keyboard.press == 'w' ) {
	moveForward(Player)
}
...
```

Now This would technically work as when the code got to this place and the player pressed 'w' then the player would move forward in the game, but there are 2 main problems with this and that is that the way the program detects the button and the time at which the player presses the button. The first problem is that the game will get to the part of the code that is shown above and then it will wait for the keyboard to be pressed and then check if that key that was pressed was the 'w' key and if it was then the program will move the player forward and if not then it will skip past. But what will happen if the player is not pressing any key on the keyboard? In this case the game will freeze at this place as it is waiting for a key to be pressed to see if it is 'w'. If you have the main code also processing the movement of enemies for example then they would not move when the keyboard is not being pressed and as such the game will not have the effect that is needed. The second example is that the program will only detect the keystroke when it is at this past in the code and if your main loop of the program takes a few seconds to go through then you will have problems. Lets say that the program has just checked the keystroke for 'w' and is now running the code just after it, lets say that you want to quickly move forward then you would quickly tap the 'w' for a split second. Due to the fact that the program is not processing the code that relates to you pressing the key at that moment then the game will not know that you wanted to move and that is a problem. If you did not use event handlers then you would have to do the event that you want to do at exactly the same time that the code checks to see if you are doing that event and this will mean that it will not work properly. In addition to this, you will also have the program stop and wait if you are not doing the type of action that it wants to detect. This is why event handlers are used. 

Instead of having the code for the detecting of events in the main section of the code it would make sense to have it in a very small and fast section of code that would run on a different CPU core as well. Well, that it the definition of an event handles and with it you can have the detection for the program work well. The way that the event handler will run in this separate state is in what is called a callback routine. And in this way, the input will not cause any of the problems that I have listed here and will actually mean that the main loop will have better performance because it will not handle the input at all. 

### Triggers

When you are programming in event driven programming, a trigger is a certain thing that is set up so that when the conditions that it has been set are met it will perform an action. In a way it is very similar to an 'if' statement that is always being checked for while the program is running. This can be included in the previously mentioned event handler, but may be done in a separate one to the one that is dedicated to the controls so that the controls are processed properly. There are many things that a trigger could be programmed to do so that the program will do what is needed. For example, you could have a program that was for a form and when a number that you put in a certain box was above the value of 100 then you could show an error message that would alert the user of the program so that they know that they used a number that was too big, even before they clicked submit. This would work by having the program check the value that was in the box over and over again so that it could be known as soon as possible. In this case the trigger would be the value in the box being over 100 and the effect that this trigger would have is that it would cause the user to be alerted to the error with a message that would appear on their screen. 

### Objects and properties

When you are programming in an event driven programming language in almost all cases the language that you are using will be what is called an 'oop'. 'oop' stands for 'Object Oriented Programming' and is a way of programming where instead of going through code one line at a time running down the program in a conventional way there is a layer of abstraction that means that you will instead deal with objects and the properties that those objects have and how they interact with each other. In this case, an object is really anything that you want it to be that will be useful in the program that you will be creating and then this object can share information from other objects that are its 'parents'. For example, if you had a game that used different animals then you might create an object called 'animal', and this object would contain the information that all animals are living and that they all have a head. Now you could then take this a step down and then have an object called 'dog' and the dog would take all the information from the 'animal' object but also provide additional information like all dogs have 4 legs and that they all have a tail. Now any dog will have the information of both the 'animal' and the 'dog'. You can then go to another level and say that you have a specific dog called 'rover' and this is the individual dog that you would have in the program, now the information that you could provide for roves could be that he is called 'rover', his fur is 'black' and his size is 'big'. Now you have all the information that you could want about rover the dog from general information all the way down to very specific information and this will help in the program. So, now lets say that you want to add a cat into the game, the cat would have the same attributes at the object 'animal' but would not be a dog and so that is where the cat object will split off on its own. As you can see, when you use objects when programming you can have certain information that would be shared down a tree and so only the things that need certain information will get that and so there is no redundancy in the program.  

### Menu's

When you are using an event driven programming language then you will most likely be programming in an 'IDE', this is an 'Integrates Development Environment' and when you are using this you will have many menus that you can use that well help you with the programming and the placing of parts of the GUI without having to manually write out the code and .xml files. One of the most commonly used IDE's would have to be Microsoft visual studio and so I will be showing the menu that is in place for that. In the image below you will see an example of the menu that you will see in Visual Studio when you are placing and setting up the main section of the GUI:

![Menu image](https://screenshots.en.sftcdn.net/en/scrn/85000/85362/microsoft-visual-studio-3.jpg)

As you can see in this image there is quite a lot to the menu that you can see and use, but the main thing that sticks out in this image would have to be the menu to the left hand side as that is the one that contains all of the GUI things that you can access and therefor use on the program itself. The way that the menu is used in this case is great as it allows the user to see all of the things that they can put on their program and so they can get exactly what they want without having to know all of the information and just write it down in plain file section by section. In addition to this, you can also see the menu off to the right hand side where you have all the information about the properties and the settings of all of the things that you place down on the GUI and so with this menu you can very easily create the interface just the way that you want it quickly and with no hustle. This then also ties in to a previous section where I went on about the quick time that it takes to develop there programs and this is one of the main reasons that this happens.  

### Debugging tools

When you are programming in any way there will always be a point when the program does not work as you want it to and in this case having the ability to use debugging tools will help you with getting the program working again. There are many different types of debugging tools that aim to give the programmer the ability to see what has gone wrong with the program that they are creating and so I cannot go through all of them now. One of the main debugging tools that is used is a breakpoint and then a memory explorer and together they provide a powerful way to debug a program and see what is not working with it. The way a breakpoint works is that it goes through and runs the program normally but when it gets to a certain point that you decide it will freeze the program immediately so that it does not run at all until you want it to. Once the program is then stopped you will be able to use a memory explorer and see the values that all of the variables in the program are at that time. (I will explain variables in the next section). Now you will be able to see if the value of any variable is not what you expected it to be, and in that case you should be able to work back through the program and see how that got the incorrect value. Some advanced debuggers allow for the program to be step by step backwards so that you can see exactly where the error came from and fix that line of code.  

### Variables

In programming on order to get the program working and running you will need the ability to save and edit sections in memory and to do this it would be good if you could give these sections of memory names in the program so that you could refer to them easily, that is what a variable is. Lets say that you had a program that would count numbers from one and then two and so on, in order to do this you would need to have a way to remember the number that you are counting with and you might want to call it 'number' so you would write the following in you program:

```
int number = 0
```

The 'int' part at the beginning means that it is a number that the computer is storing rather then a work or something. Now, in your computer when you run this program a section in the RAM of the computer will be set aside for use with this program and in will be the size of an integer and will be accessible only through the program and will be accessed in that program by the name of 'number'. Now in the program if you wanted to add to that number then you would tell the computer the action that you would want to perform to that variable, say if you wanted to add 1 then you would want to write something like this:

```
number = number + 1;
```

This will take the variable of number and change its value to what its current value is plus 1 and write that to the section of memory called by 'number'. That is basically how variables work, so if you wanted to set another variable in the program called 'count' to twice the value of number minus 1 then you would write:

```
count = (number * 2) + 1
```
And with this the value will be set correctly. 

### Scope of variables

One other thing that is a factor that comes into the names that you give for the names of the variables it that you need to take into account the scope that the variable was created in and the scope that it can be used in. Below I will show an example of three different variables that are in 3 different scopes:

```
int golbvar = 0;

int add( int x, int y)
{
	int addvar = x + y;
}

int main()
{
	int mainvar = 0;
	add(1, 0);
}
```

It this code there are 3 scopes that are used, two for the functions of main and add and one more global. In this program the code is written in C and there are 2 functions, 'main' and 'add'. When you define a variable it is only used in the scope that it was created in and if you have a variable with the same name in another scope then they will not be the same variable and they would have different values. In the example above the variable 'globvar' is created (defined) outside of a function so it will be able to be used in any function in the program and will keep the same value in all of them, so you could get another value from the add function by writing to the 'golbvar' variable and then reading that in the main function. So the 'globvar' function is in the global scope. Now for the variables of 'mainvar' and 'addvar' because they are defined inside a function (different scope) they can only be used in that function. By this I mean that the variable 'mainvar' can only be accessed in the main function and so if you tried to accessed it in the add function then you would create a different variable and would not be able to access the data. This is the same the other way around as well as the 'addvar' cannot be accessed in the main function, so the main function is not special in this respect. 

### Constants

In addition to having variables when you are programming it is also in program at to have constants as will that will store information all through the program that can then be all the same with a name so that the constant makes sense. A constant is basically a variable that you cannot change during the execution of the program, so it works by allocating a section in memory and then letting that be accessed through the use of name in the program. However a constant differs by only allowing you to read the value that it contains rather then writing and reading it like a variable would allow. Below you will see two examples in C of how a constant is used:

```
#define PI 3.14159;
const float tauValues[] = {1.5707964, 3.0845639, 5.239875};

...
...
...

c = PI * diameter;

for ( i = 0; i < 3; i++) {
	tauFunc(tauValues[i])
}
```

As you can see here there are two ways that constants can be defined in C and they are just slightly similar but a few small differences. The main different between them is that the '#define' method does not use a certain data type but it it inferred from the data that it put in for the definition and all that it does is that is replaces all the occurrences of the define word with the value at compile time. In a slight contrast the const method will not just swap out all the values with what they are told to be in a way that the define method works, but it instead it acts like a variable that you can only read from that is a certain type. Due to the each that it is a certain type you will be able to do more things with the const but it is not good for just swapping out values like the define method is. You can see this in the example above as the define only works to swap out values (the convention is to use all caps for define words to that they stand out from variables) while the const can be used for more complicated things like an array that you can only read from.   

### Data types

As mentioned before all the variables that you make will have to have a data type associated with them. This it done so that the compiler will be able to allocate the correct size of space in the RAM of the computer for that variable to be stored. There are many different data types that exist and to at the end of this section I will be going through and showing the table for reference. To start with though there are two main types for a data type and that is water it will be storing a number or text (string) and so different types of numbers and strings take different sizes to store. The main type of data type for numbers would be an 'int' type, this is a value that takes up 32 bits of information in the RAM, this then allows for 2^32 numbers half of which are positive, half of which are negative. So if you wanted to store information that would never go above the value of 2,147,483,646 then you would use an integer. However, if you wanted to store a value that could go above that then you would have to use a float. If you do not use the correct data type then you will either use up too much RAM for what you want (that is not too much of an issue now though) or there will not be enough room to store the value that you want and so the program will crash. Here is a table for reference about the data types that are available:

![Data types](http://img.c4learn.com/2012/03/Primitive-Data-Types-in-Java-Programming-Language.png)

## M1 - Discuss how an operating system can be viewed as an event driven application

When you are talking about an operating system and how it works you will see that there is a certain similarity that exists between it and the way that an event driven program works, so in this section I will go through how they are similar and how they are the same in some respects but different in others. To start off with I will go through examples of how an operating system is similar to an event driven program.  

### Examples

To start off with, in an abstract sense, an operating system is just a program that is used to use other program so by itself there is not much that it can do. This is where the similarities start as if you recall to before then you will know that event driven programming is in place to help a user use the program and do what they want to do by clicking and using other forms of input like a mouse and so on. All of that sounds very similar to Windows as with this you will have a blank area that you will click on and used the mouse with to interact with it. A main example of this would be the windows button that is in the lower left corner of the desktop. I say that this is a main feature as the windows button is used very frequently and is also activated with events that an event driven program would use like mouse clicks and button presses. In fact the windows button would be programmed as a trigger that would run in the background and will wait for either a mouse press or a windows key button press, this would most likely run in an event handler that would be waiting for either of the events to happen. Then, once the requirements for the trigger is met, the windows key would activate and then it would open like you would expect. Another example of this would be that whenever the user presses a key on the keyboard it is captured by the system and then the relevant actions are taken on the operating system. You may think that this would be obvious but when you compare it to a functional programming language like C then you can see that that would not work as you would always have to be manually checking input and seeing if they did anything but with event driven programming this is not the case and so it would work. Furthermore, with a functional programming language everything would be a bit more hard coded and so editing actions for specific cases would not work too well. This then extends to the mouse as well as all that information has to be detected and then processed like the keyboard would have to. I could go on with many more examples but you get the idea that they will all be detecting the user input and then process that and it will have objects and so on. 

### Advantages of an event driven operating system

Due to the fact operating systems at the moment are written in event driven ways then there will be many advantages to doing it this way and I will go through a few of those. As mentioned in the previous section, one of the main advantages that event driven programming will bring to operating systems is the ability to capture and process the user input into the machine from many different input devices, but mainly the keyboard and the mouse. With event driven programming the way that these are captured and processes is far much simpler and more efficient than other programming methods, this will therefor lead to the creation of the operating system being quicker. In addition to this, the performance of this will also be improved and therefor it will run faster. Another advantage is that the 'oop' programs will be able to execute in more than one thread at a time, this will mean that the operating system will be able to use the hardware that it runs on more effectively and will therefor also have better performance. This is due to the fact that languages like C cannot use more that one thread of execution and so they will only be able to use one thread per program and this will lead to the operating system needing to run multiple programs at the same time to that the whole system's resources are used well and then those programs will have to communicate by writing to the disk and as you can see, this can get complicated. A final advantage is that when you are using an event driven programming method for an operating system then you can easily have all of the windows and menus act as an object and then you can have all the similar ones get the attributes of a template for its type as mentioned in an earlier section, this will therefor ensure that there is less redundancy in the system and so the code will therefor be smaller. In addition to this, this also allows for when the time comes to update the system having a simpler process as you will then only have to update the windows group with the new attributes and then all the windows that will be created will have the new update applied, this will then be system wide immediately. 

### Disadvantages of an event driven operating system

However, as always when there are advantages there are also some disadvantages, but in this case there are not many. One of the first disadvantages that comes to mind when programming an operating system in event driven programming is that there will need to be some tasks that will need to happen in the background that cannot be started by the user, but that will need to be started by the computer when it boots up. With this I am talking about things like hard drive cashing, anti-virus and so on. Although you could have them start outside of the main section of the code so that they run when the code starts, this is not really the way that it should work with event driven programming and it could also cause many different problems with anything and so it is really not advisable. Another disadvantage with this is that it is a far more difficult to change and edit singular parts of the operating system to how you want it in a specific case as it is all merged with everything and so changing one part is likely to change another and this can lead to many problems that you would not fast otherwise. 

<div style="page-break-after: always;"></div>

## Bibliography









































<div style="page-break-after: always;"></div>
-
<div style="page-break-after: always;"></div>
-
<div style="page-break-after: always;"></div>
-
<div style="page-break-after: always;"></div>
-
<div style="page-break-after: always;"></div>
-
<div style="page-break-after: always;"></div>
-
<div style="page-break-after: always;"></div>
-
<div style="page-break-after: always;"></div>
-
<div style="page-break-after: always;"></div>
-
<div style="page-break-after: always;"></div>
-
<div style="page-break-after: always;"></div>
-
<div style="page-break-after: always;"></div>
-
<div style="page-break-after: always;"></div>
-
<div style="page-break-after: always;"></div>
-
<div style="page-break-after: always;"></div>
-
<div style="page-break-after: always;"></div>
-
<div style="page-break-after: always;"></div>
-
<div style="page-break-after: always;"></div>
-
<div style="page-break-after: always;"></div>
-
<div style="page-break-after: always;"></div>
-
